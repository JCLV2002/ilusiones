function centroids = initialize_centroids(X, k)
    % Inicializar los centroides seleccionando k muestras aleatorias
    idx = randperm(size(X, 1));
    centroids = X(idx(1:k), :);
end

function clusters = assign_clusters(X, centroids)
    % Asignar cada muestra al centroide más cercano
    m = size(X, 1);
    k = size(centroids, 1);
    clusters = zeros(m, 1);
    for i = 1:m
        min_distance = realmax; % Inicializar la distancia mínima como infinito
        for j = 1:k
            distance = norm(X(i, :) - centroids(j, :)); % Calcular la distancia euclidiana
            if distance < min_distance
                min_distance = distance;
                clusters(i) = j;
            end
        end
    end
end


function new_centroids = update_centroids(X, clusters, k)
    % Calcular los nuevos centroides basados en las muestras asignadas a cada cluster
    new_centroids = zeros(k, size(X, 2));
    for i = 1:k
        cluster_points = X(clusters == i, :);
        if ~isempty(cluster_points)
            new_centroids(i, :) = mean(cluster_points);
        else
            new_centroids(i, :) = X(randi(size(X, 1)), :);
        end
    end
end

function [clusters, centroids] = k_means(X, k, max_iterations)
    centroids = initialize_centroids(X, k);
    for iter = 1:max_iterations
        clusters = assign_clusters(X, centroids);
        new_centroids = update_centroids(X, clusters, k);
        % Comprobar si los centroides convergieron
        if isequal(centroids, new_centroids)
            break;
        end
        centroids = new_centroids;
    end
end

% Seleccionar los atributos para la aplicación de K-Means
X = data(:, 1:4);

% Normalizar los datos para asegurar que todas las características tengan el mismo peso
X = zscore(X);

% Especificar el número de clusters
k = 3;

% Ejecutar el algoritmo K-means
[clusters, centroids] = k_means(X, k, 100);

% Visualizar los resultados
fprintf('Centroides finales:\n');
disp(centroids);
